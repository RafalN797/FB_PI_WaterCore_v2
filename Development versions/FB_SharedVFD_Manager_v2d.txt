FUNCTION_BLOCK FB_SharedVFD_Manager_v2d
{ S7_Optimized_Access := 'TRUE' }
// Two pumps on one VFD, anti-chatter, with 10 s contactor hold after manual STOP.
// States: 0=READY, 10=RUN_OFF (switching), 40=DEADTIME

VAR_INPUT
  bEn               : BOOL := TRUE;
  bLocal_P1         : BOOL := FALSE;
  bLocal_P2         : BOOL := FALSE;

  // Auto side
  bAutoDemand       : BOOL := FALSE;     // request RUN (suppressed by any Local)
  bAutoSel_P1       : BOOL := TRUE;
  bAutoSel_P2       : BOOL := FALSE;

  // Optional PB (używane tylko jeśli chcesz)
  bPB_Start         : BOOL := FALSE;
  bPB_Stop          : BOOL := FALSE;

  // Interlocks / feedbacks
  bPermOk           : BOOL := TRUE;
  bVFD_Fault        : BOOL := FALSE;
  bVFD_RunFB        : BOOL := FALSE;
  bFb_K1            : BOOL := FALSE;
  bFb_K2            : BOOL := FALSE;

  // Timings
  T_LocalDebounce   : TIME := T#200ms;
  T_StopToOpen      : TIME := T#10s;     // <-- 10 s hold po STOP w manualu
  T_Deadtime        : TIME := T#300ms;
END_VAR

VAR_OUTPUT
  bDO_K1            : BOOL;
  bDO_K2            : BOOL;
  bDO_VFD_Run       : BOOL;
  iOwner            : INT;               // 0/1/2
  iSwState          : INT;               // 0/10/40
  bBusySwitch       : BOOL;
  bAlm_BothFb       : BOOL;
END_VAR

VAR
  // Debounce Local
  tonLoc1, tonLoc2  : TON;
  bLoc1_Db, bLoc2_Db: BOOL;

  // FSM timers
  tonStopToOpen     : TON;               // uzywany przy SWITCH i po manual STOP
  tonDead           : TON;

  // RUN latch
  rtrStart, rtrStop : R_TRIG;
  bRunLatch         : BOOL := FALSE;
  bRunLatchPrev     : BOOL := FALSE;     // do wykrycia zbocza opadajacego
  bPostStopHoldActive : BOOL := FALSE;   // trzymanie stycznika po STOP (manual)

  // Ownering
  iOwner_Int        : INT := 0;
  iDesiredOwner     : INT := 0;

  // Flags
  bAnyLocal         : BOOL;
  bPermAllOk        : BOOL;
  bAutoAsk          : BOOL;
  bHoldContactors   : BOOL;              // wynikowa flaga: trzymac stycznik?

  bFirstScan        : BOOL := TRUE;
END_VAR

BEGIN
  // Defaults
  bDO_K1 := FALSE; bDO_K2 := FALSE; bDO_VFD_Run := FALSE; bAlm_BothFb := FALSE;

  IF bFirstScan THEN
    iSwState := 0; iOwner_Int := 0; bRunLatch := FALSE; bRunLatchPrev := FALSE;
    tonLoc1(IN := FALSE, PT := T_LocalDebounce);
    tonLoc2(IN := FALSE, PT := T_LocalDebounce);
    tonStopToOpen(IN := FALSE, PT := T_StopToOpen);
    tonDead(IN := FALSE, PT := T_Deadtime);
    bFirstScan := FALSE;
  END_IF;

  // Global
  bPermAllOk := bEn AND bPermOk AND (NOT bVFD_Fault);

  // Debounce Local
  tonLoc1(IN := bLocal_P1, PT := T_LocalDebounce);
  tonLoc2(IN := bLocal_P2, PT := T_LocalDebounce);
  bLoc1_Db := tonLoc1.Q; bLoc2_Db := tonLoc2.Q;
  bAnyLocal := bLoc1_Db OR bLoc2_Db;

  // Alarm: oba FB stycznikow
  IF bFb_K1 AND bFb_K2 THEN bAlm_BothFb := TRUE; END_IF;

  // Desired owner (Local priorytet, inaczej AUTO preferencja)
  IF bLoc1_Db THEN
    iDesiredOwner := 1;
  ELSIF bLoc2_Db THEN
    iDesiredOwner := 2;
  ELSE
    IF bAutoSel_P1 AND (NOT bAutoSel_P2) THEN
      iDesiredOwner := 1;
    ELSIF bAutoSel_P2 AND (NOT bAutoSel_P1) THEN
      iDesiredOwner := 2;
    ELSE
      iDesiredOwner := iOwner_Int; // brak zmiany
    END_IF;
  END_IF;

  // AutoDemand wyciszane przy Local
  IF bAnyLocal THEN bAutoAsk := FALSE; ELSE bAutoAsk := bAutoDemand; END_IF;

  // PB edges
  rtrStart(CLK := bPB_Start);
  rtrStop (CLK := bPB_Stop);

  // ---------------- FSM (switching) ----------------
  CASE iSwState OF
    // READY
    0:
      // RUN latch normalnie tylko gdy nie przełączamy
      IF (iOwner_Int = iDesiredOwner) THEN
        IF (rtrStart.Q OR bAutoAsk) AND bPermAllOk AND (iOwner_Int <> 0) THEN
          bRunLatch := TRUE;
        END_IF;
        IF rtrStop.Q OR (NOT bAutoAsk) OR (NOT bPermAllOk) THEN
          bRunLatch := FALSE;
        END_IF;
      ELSE
        // musimy przelaczyc galez
        bRunLatch := FALSE;                            // RUN dol
        tonStopToOpen(IN := TRUE, PT := T_StopToOpen); // czekamy przed otwarciem
        iSwState := 10;                                // RUN_OFF
      END_IF;

    // RUN_OFF (przy przelaczaniu galezi): RUN=0, czekamy T_StopToOpen lub RUNFB=0
    10:
      tonStopToOpen(IN := TRUE, PT := T_StopToOpen);
      IF tonStopToOpen.Q OR (NOT bVFD_RunFB) THEN
        tonStopToOpen(IN := FALSE, PT := T_StopToOpen);
        iOwner_Int := iDesiredOwner;                   // nowy owner
        tonDead(IN := TRUE, PT := T_Deadtime);
        iSwState := 40;                                // DEADTIME
      END_IF;

    // DEADTIME: wszystko otwarte
    40:
      tonDead(IN := TRUE, PT := T_Deadtime);
      IF tonDead.Q THEN
        tonDead(IN := FALSE, PT := T_Deadtime);
        iSwState := 0;                                 // READY
      END_IF;

  ELSE
    iSwState := 0;
  END_CASE;

  // ---------------- 10 s HOLD po manual STOP ----------------
  // wykryj zbocze opadajace RUN (przed aktualizacja prev)
  VAR_TEMP bRunDropEdge : BOOL;
  bRunDropEdge := (bRunLatchPrev AND (NOT bRunLatch));

  // Gdy manual (Local aktywny) i NIE przełączamy galezi (iSwState=0, owner bez zmiany)
  // – uruchom post-stop hold i trzymaj stycznik przez T_StopToOpen.
  IF (iSwState = 0) AND bAnyLocal AND (iOwner_Int = iDesiredOwner) THEN
    IF bRunDropEdge THEN
      bPostStopHoldActive := TRUE;
      tonStopToOpen(IN := TRUE, PT := T_StopToOpen);   // start hold
    END_IF;

    // zakończenie hold
    IF tonStopToOpen.Q THEN
      tonStopToOpen(IN := FALSE, PT := T_StopToOpen);
      bPostStopHoldActive := FALSE;
    END_IF;
  ELSE
    // w innych sytuacjach (AUTO / switching) — brak manual hold
    bPostStopHoldActive := FALSE;
    // Uwaga: tonStopToOpen moze byc uzywany przez FSM (stany 10/40)
  END_IF;

  // zapisz poprzednie
  bRunLatchPrev := bRunLatch;

  // ---------------- Wyjścia ----------------
  // RUN tylko w READY
  IF iSwState = 0 THEN
    bDO_VFD_Run := bRunLatch AND bPermAllOk AND (iOwner_Int <> 0);
  ELSE
    bDO_VFD_Run := FALSE;
  END_IF;

  // Czy trzymamy stycznik?
  // - podczas switching (10/40): otwarte
  // - w READY: trzymamy gdy RUN=TRUE LUB trwa hold po manual STOP
  IF iSwState = 0 THEN
    bHoldContactors := bDO_VFD_Run OR bPostStopHoldActive;
  ELSE
    bHoldContactors := FALSE;
  END_IF;

  // Sterowanie cewkami
  IF bHoldContactors THEN
    IF iOwner_Int = 1 THEN
      bDO_K1 := TRUE; bDO_K2 := FALSE;
    ELSIF iOwner_Int = 2 THEN
      bDO_K1 := FALSE; bDO_K2 := TRUE;
    ELSE
      bDO_K1 := FALSE; bDO_K2 := FALSE;
    END_IF;
  ELSE
    bDO_K1 := FALSE; bDO_K2 := FALSE;
  END_IF;

  // Status
  iOwner      := iOwner_Int;
  bBusySwitch := (iSwState <> 0);

END_FUNCTION_BLOCK
